// Code generated by protoc-gen-go.
// source: plugin.proto
// DO NOT EDIT!

package protos

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type PluginRequest_OptionType int32

const (
	PluginRequest_STRING PluginRequest_OptionType = 0
	PluginRequest_BOOL   PluginRequest_OptionType = 1
	PluginRequest_INT    PluginRequest_OptionType = 2
)

var PluginRequest_OptionType_name = map[int32]string{
	0: "STRING",
	1: "BOOL",
	2: "INT",
}
var PluginRequest_OptionType_value = map[string]int32{
	"STRING": 0,
	"BOOL":   1,
	"INT":    2,
}

func (x PluginRequest_OptionType) String() string {
	return proto.EnumName(PluginRequest_OptionType_name, int32(x))
}

type PluginReply_OutputType int32

const (
	PluginReply_JSON PluginReply_OutputType = 0
	PluginReply_TEXT PluginReply_OutputType = 1
)

var PluginReply_OutputType_name = map[int32]string{
	0: "JSON",
	1: "TEXT",
}
var PluginReply_OutputType_value = map[string]int32{
	"JSON": 0,
	"TEXT": 1,
}

func (x PluginReply_OutputType) String() string {
	return proto.EnumName(PluginReply_OutputType_name, int32(x))
}

type PluginRequest struct {
	Option []*PluginRequest_Option `protobuf:"bytes,1,rep,name=option" json:"option,omitempty"`
}

func (m *PluginRequest) Reset()         { *m = PluginRequest{} }
func (m *PluginRequest) String() string { return proto.CompactTextString(m) }
func (*PluginRequest) ProtoMessage()    {}

func (m *PluginRequest) GetOption() []*PluginRequest_Option {
	if m != nil {
		return m.Option
	}
	return nil
}

type PluginRequest_Option struct {
	Name  string                   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value string                   `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Type  PluginRequest_OptionType `protobuf:"varint,3,opt,name=type,enum=protos.PluginRequest_OptionType" json:"type,omitempty"`
}

func (m *PluginRequest_Option) Reset()         { *m = PluginRequest_Option{} }
func (m *PluginRequest_Option) String() string { return proto.CompactTextString(m) }
func (*PluginRequest_Option) ProtoMessage()    {}

type PluginReply struct {
	Output string `protobuf:"bytes,1,opt,name=output" json:"output,omitempty"`
}

func (m *PluginReply) Reset()         { *m = PluginReply{} }
func (m *PluginReply) String() string { return proto.CompactTextString(m) }
func (*PluginReply) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("protos.PluginRequest_OptionType", PluginRequest_OptionType_name, PluginRequest_OptionType_value)
	proto.RegisterEnum("protos.PluginReply_OutputType", PluginReply_OutputType_name, PluginReply_OutputType_value)
}

// Client API for Plugin service

type PluginClient interface {
	Execute(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*PluginReply, error)
}

type pluginClient struct {
	cc *grpc.ClientConn
}

func NewPluginClient(cc *grpc.ClientConn) PluginClient {
	return &pluginClient{cc}
}

func (c *pluginClient) Execute(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*PluginReply, error) {
	out := new(PluginReply)
	err := grpc.Invoke(ctx, "/protos.Plugin/Execute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Plugin service

type PluginServer interface {
	Execute(context.Context, *PluginRequest) (*PluginReply, error)
}

func RegisterPluginServer(s *grpc.Server, srv PluginServer) {
	s.RegisterService(&_Plugin_serviceDesc, srv)
}

func _Plugin_Execute_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(PluginRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(PluginServer).Execute(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Plugin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Plugin",
	HandlerType: (*PluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _Plugin_Execute_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
